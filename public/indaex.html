<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZoneSpark - Instant Speed Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            overflow: hidden;
        }

        .container {
            text-align: center;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            position: relative;
        }

        .logo {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #00f5ff, #ff006e, #8338ec);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.3));
        }

        .speed-container {
            position: relative;
            margin: 2rem 0;
        }

        .speed-display {
            font-size: 5rem;
            font-weight: 900;
            line-height: 1;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
            transition: all 0.2s ease;
            font-variant-numeric: tabular-nums;
        }

        .speed-unit {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 400;
            margin-left: 8px;
        }

        .status {
            font-size: 1.1rem;
            margin: 1rem 0;
            opacity: 0.9;
            min-height: 30px;
            transition: all 0.3s ease;
        }

        .start-btn {
            background: linear-gradient(45deg, #00f5ff, #ff006e);
            border: none;
            padding: 16px 48px;
            font-size: 1.1rem;
            font-weight: 600;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 8px 25px rgba(0, 245, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0, 245, 255, 0.4);
        }

        .start-btn:active {
            transform: translateY(0);
        }

        .start-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        .progress-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .progress-ring.active {
            opacity: 1;
        }

        .progress-ring circle {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            transform-origin: center;
            transform: rotate(-90deg);
            transition: stroke-dashoffset 0.3s ease;
        }

        .progress-ring .bg {
            stroke: rgba(255, 255, 255, 0.1);
        }

        .progress-ring .progress {
            stroke: url(#gradient);
            stroke-dasharray: 628;
            stroke-dashoffset: 628;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 2rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }

        .stats.show {
            opacity: 1;
            transform: translateY(0);
        }

        .stat {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.85rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .network-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            opacity: 0.6;
            text-align: center;
        }

        .pulse {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        .testing {
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(255, 255, 255, 0.4); }
            to { text-shadow: 0 0 40px rgba(0, 245, 255, 0.6); }
        }

        @media (max-width: 768px) {
            .speed-display { font-size: 4rem; }
            .stats { grid-template-columns: 1fr; gap: 15px; }
            .logo { font-size: 2rem; }
        }

        .instant-feedback {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            opacity: 0;
            transition: all 0.3s ease;
            color: #00f5ff;
        }

        .instant-feedback.show {
            opacity: 1;
            top: -40px;
        }

        .connection-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 10px 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .connection-dots.show {
            opacity: 1;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00f5ff;
            animation: wave 1.4s ease-in-out infinite;
        }

        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes wave {
            0%, 60%, 100% { transform: scale(1); opacity: 0.5; }
            30% { transform: scale(1.5); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="logo">NTspark</h1>
        
        <div class="speed-container">
            <div class="instant-feedback" id="feedback"></div>
            <div class="speed-display" id="speedDisplay">
                <span id="speedValue">--</span>
                <span class="speed-unit">Mbps</span>
            </div>
            
            <svg class="progress-ring" id="progressRing">
                <defs>
                    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#00f5ff"/>
                        <stop offset="100%" style="stop-color:#ff006e"/>
                    </linearGradient>
                </defs>
                <circle class="bg" cx="100" cy="100" r="100"/>
                <circle class="progress" cx="100" cy="100" r="100" id="progressCircle"/>
            </svg>
        </div>

        <div class="status" id="status">Ready to test your internet speed</div>
        
        <div class="connection-dots" id="connectionDots">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
        </div>

        <button class="start-btn" id="startBtn" onclick="startTest()">
            <span id="btnText">GO</span>
        </button>

        <div class="stats" id="stats">
            <div class="stat">
                <div class="stat-value" id="downloadStat">--</div>
                <div class="stat-label">Download</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="uploadStat">--</div>
                <div class="stat-label">Upload</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="pingStat">--</div>
                <div class="stat-label">Ping</div>
            </div>
        </div>

        <div class="network-info" id="networkInfo">
            <div>Detecting location...</div>
        </div>
    </div>

    <script>
        class FastSpeedTest {
            constructor() {
                this.isRunning = false;
                this.testData = {
                    download: 0,
                    upload: 0,
                    ping: 0
                };
                this.testUrls = [
                    'https://httpbin.org/bytes/',
                    'https://jsonplaceholder.typicode.com/posts',
                    'https://api.github.com/users/octocat'
                ];
                this.init();
            }

            async init() {
                // Quick network info detection
                this.detectNetworkInfo();
                
                // Pre-warm connections for faster testing
                this.preWarmConnections();
            }

            async detectNetworkInfo() {
                try {
                    const start = performance.now();
                    const response = await fetch('https://httpbin.org/ip', {
                        method: 'GET',
                        cache: 'no-cache'
                    });
                    const data = await response.json();
                    const ping = performance.now() - start;
                    
                    document.getElementById('networkInfo').innerHTML = `
                        <div>IP: ${data.origin} • Ping: ${Math.round(ping)}ms</div>
                    `;
                    
                    // Show instant feedback
                    this.showFeedback(`Connected in ${Math.round(ping)}ms`);
                } catch (error) {
                    document.getElementById('networkInfo').innerHTML = `<div>Connection ready</div>`;
                }
            }

            async preWarmConnections() {
                // Pre-establish connections to test servers
                const promises = this.testUrls.slice(0, 2).map(url => 
                    fetch(url + '100', { method: 'HEAD', cache: 'no-cache' }).catch(() => {})
                );
                await Promise.allSettled(promises);
            }

            showFeedback(message) {
                const feedback = document.getElementById('feedback');
                feedback.textContent = message;
                feedback.classList.add('show');
                setTimeout(() => feedback.classList.remove('show'), 2000);
            }

            updateProgress(percent) {
                const circle = document.getElementById('progressCircle');
                const circumference = 2 * Math.PI * 100;
                const offset = circumference - (percent / 100) * circumference;
                circle.style.strokeDashoffset = offset;
            }

            updateDisplay(value, suffix = 'Mbps', isActive = false) {
                const speedValue = document.getElementById('speedValue');
                const speedDisplay = document.getElementById('speedDisplay');
                
                speedValue.textContent = value;
                speedDisplay.className = isActive ? 'speed-display testing' : 'speed-display';
            }

            async quickPingTest() {
                const pings = [];
                const pingPromises = [];
                
                // Rapid ping measurement with 3 concurrent requests
                for (let i = 0; i < 3; i++) {
                    pingPromises.push(this.measureSinglePing());
                }
                
                const results = await Promise.allSettled(pingPromises);
                results.forEach(result => {
                    if (result.status === 'fulfilled' && result.value > 0) {
                        pings.push(result.value);
                    }
                });
                
                return pings.length > 0 ? pings.reduce((a, b) => a + b) / pings.length : 25;
            }

            async measureSinglePing() {
                const start = performance.now();
                try {
                    await fetch('https://httpbin.org/bytes/1', {
                        method: 'GET',
                        cache: 'no-cache',
                        signal: AbortSignal.timeout(2000)
                    });
                    return performance.now() - start;
                } catch (error) {
                    return 0;
                }
            }

            async rapidDownloadTest() {
                const testDuration = 3000; // Only 3 seconds for speed
                const startTime = performance.now();
                let totalBytes = 0;
                let maxSpeed = 0;

                // Start multiple concurrent downloads immediately
                const downloadPromises = [];
                const sizes = [500, 1000, 2000]; // KB sizes
                
                for (let size of sizes) {
                    downloadPromises.push(this.downloadChunk(size * 1024));
                }

                while (performance.now() - startTime < testDuration && this.isRunning) {
                    try {
                        const result = await Promise.race(downloadPromises.filter(p => p));
                        
                        if (result && result.bytes > 0) {
                            totalBytes += result.bytes;
                            const elapsed = (performance.now() - startTime) / 1000;
                            const currentSpeed = (totalBytes * 8) / (elapsed * 1024 * 1024);
                            
                            maxSpeed = Math.max(maxSpeed, currentSpeed);
                            this.updateDisplay(currentSpeed.toFixed(1), 'Mbps', true);
                            
                            // Update progress
                            const progress = Math.min((elapsed / (testDuration / 1000)) * 70, 70);
                            this.updateProgress(progress);
                        }
                        
                        // Start new download
                        const newSize = sizes[Math.floor(Math.random() * sizes.length)];
                        downloadPromises.push(this.downloadChunk(newSize * 1024));
                        
                        await new Promise(resolve => setTimeout(resolve, 50)); // Very fast updates
                        
                    } catch (error) {
                        // Use simulated speed for demo if real test fails
                        const elapsed = (performance.now() - startTime) / 1000;
                        const simSpeed = Math.random() * 50 + 20;
                        maxSpeed = Math.max(maxSpeed, simSpeed);
                        this.updateDisplay(simSpeed.toFixed(1), 'Mbps', true);
                        
                        const progress = Math.min((elapsed / (testDuration / 1000)) * 70, 70);
                        this.updateProgress(progress);
                        
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }

                return maxSpeed;
            }

            async downloadChunk(size) {
                try {
                    const start = performance.now();
                    const response = await fetch(`https://httpbin.org/bytes/${size}`, {
                        cache: 'no-cache',
                        signal: AbortSignal.timeout(5000)
                    });
                    const data = await response.arrayBuffer();
                    const duration = performance.now() - start;
                    
                    return {
                        bytes: data.byteLength,
                        duration: duration
                    };
                } catch (error) {
                    return { bytes: 0, duration: 0 };
                }
            }

            async quickUploadTest() {
                const testData = new ArrayBuffer(50 * 1024); // 50KB test data
                const startTime = performance.now();
                
                try {
                    const uploadStart = performance.now();
                    await fetch('https://httpbin.org/post', {
                        method: 'POST',
                        body: testData,
                        signal: AbortSignal.timeout(3000)
                    });
                    const duration = (performance.now() - uploadStart) / 1000;
                    const uploadSpeed = (testData.byteLength * 8) / (duration * 1024 * 1024);
                    
                    this.updateProgress(90);
                    return uploadSpeed;
                } catch (error) {
                    // Simulated upload speed
                    return Math.random() * 30 + 10;
                }
            }

            async start() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                
                // Update UI
                document.getElementById('startBtn').disabled = true;
                document.getElementById('btnText').textContent = 'Testing...';
                document.getElementById('progressRing').classList.add('active');
                document.getElementById('connectionDots').classList.add('show');
                document.getElementById('status').textContent = 'Initializing test...';
                
                try {
                    // Phase 1: Quick ping (0.5 seconds)
                    document.getElementById('status').textContent = 'Measuring ping...';
                    const ping = await this.quickPingTest();
                    this.testData.ping = ping;
                    this.updateDisplay(Math.round(ping), 'ms');
                    this.updateProgress(10);
                    
                    if (!this.isRunning) return;
                    
                    // Phase 2: Rapid download test (3 seconds)
                    document.getElementById('status').textContent = 'Testing download speed...';
                    this.showFeedback('Measuring bandwidth...');
                    
                    const downloadSpeed = await this.rapidDownloadTest();
                    this.testData.download = downloadSpeed;
                    
                    if (!this.isRunning) return;
                    
                    // Phase 3: Quick upload test (1.5 seconds)
                    document.getElementById('status').textContent = 'Testing upload...';
                    const uploadSpeed = await this.quickUploadTest();
                    this.testData.upload = uploadSpeed;
                    
                    // Complete test
                    this.completeTest();
                    
                } catch (error) {
                    console.error('Test error:', error);
                    this.completeTest();
                }
            }

            completeTest() {
                this.isRunning = false;
                this.updateProgress(100);
                
                // Show final download speed
                this.updateDisplay(this.testData.download.toFixed(1), 'Mbps', false);
                document.getElementById('status').textContent = 'Test completed!';
                
                // Update stats
                document.getElementById('downloadStat').textContent = this.testData.download.toFixed(1) + ' Mbps';
                document.getElementById('uploadStat').textContent = this.testData.upload.toFixed(1) + ' Mbps';
                document.getElementById('pingStat').textContent = Math.round(this.testData.ping) + ' ms';
                
                // Show results
                document.getElementById('stats').classList.add('show');
                
                // Reset UI
                setTimeout(() => {
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('btnText').textContent = 'Test Again';
                    document.getElementById('progressRing').classList.remove('active');
                    document.getElementById('connectionDots').classList.remove('show');
                }, 1000);
                
                this.showFeedback(`${this.testData.download.toFixed(1)} Mbps detected!`);
            }

            stop() {
                this.isRunning = false;
                this.completeTest();
            }
        }

        // Initialize
        const speedTest = new FastSpeedTest();

        function startTest() {
            if (speedTest.isRunning) {
                speedTest.stop();
            } else {
                // Reset stats
                document.getElementById('stats').classList.remove('show');
                speedTest.start();
            }
        }

        // Auto-start detection after 2 seconds for demo
        setTimeout(() => {
            if (!speedTest.isRunning) {
                document.getElementById('status').textContent = 'Ready! Click GO to start instant test';
            }
        }, 2000);
    </script>
</body>
</html> -->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NTspark - Accurate Speed Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            overflow: hidden;
        }

        .container {
            text-align: center;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            position: relative;
        }

        .logo {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #00f5ff, #ff006e, #8338ec);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.3));
        }

        .speed-container {
            position: relative;
            margin: 2rem 0;
        }

        .speed-display {
            font-size: 5rem;
            font-weight: 900;
            line-height: 1;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
            transition: all 0.2s ease;
            font-variant-numeric: tabular-nums;
        }

        .speed-unit {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 400;
            margin-left: 8px;
        }

        .status {
            font-size: 1.1rem;
            margin: 1rem 0;
            opacity: 0.9;
            min-height: 30px;
            transition: all 0.3s ease;
        }

        .start-btn {
            background: linear-gradient(45deg, #00f5ff, #ff006e);
            border: none;
            padding: 16px 48px;
            font-size: 1.1rem;
            font-weight: 600;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 8px 25px rgba(0, 245, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0, 245, 255, 0.4);
        }

        .start-btn:active {
            transform: translateY(0);
        }

        .start-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        .progress-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .progress-ring.active {
            opacity: 1;
        }

        .progress-ring circle {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            transform-origin: center;
            transform: rotate(-90deg);
            transition: stroke-dashoffset 0.3s ease;
        }

        .progress-ring .bg {
            stroke: rgba(255, 255, 255, 0.1);
        }

        .progress-ring .progress {
            stroke: url(#gradient);
            stroke-dasharray: 628;
            stroke-dashoffset: 628;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 2rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }

        .stats.show {
            opacity: 1;
            transform: translateY(0);
        }

        .stat {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.85rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .network-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            opacity: 0.6;
            text-align: center;
        }

        .pulse {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        .testing {
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(255, 255, 255, 0.4); }
            to { text-shadow: 0 0 40px rgba(0, 245, 255, 0.6); }
        }

        @media (max-width: 768px) {
            .speed-display { font-size: 4rem; }
            .stats { grid-template-columns: 1fr; gap: 15px; }
            .logo { font-size: 2rem; }
        }

        .instant-feedback {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            opacity: 0;
            transition: all 0.3s ease;
            color: #00f5ff;
        }

        .instant-feedback.show {
            opacity: 1;
            top: -40px;
        }

        .connection-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 10px 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .connection-dots.show {
            opacity: 1;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00f5ff;
            animation: wave 1.4s ease-in-out infinite;
        }

        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes wave {
            0%, 60%, 100% { transform: scale(1); opacity: 0.5; }
            30% { transform: scale(1.5); opacity: 1; }
        }

        .accuracy-indicator {
            position: absolute;
            top: -60px;
            right: -20px;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            border-radius: 20px;
            padding: 5px 15px;
            font-size: 0.8rem;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .accuracy-indicator.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="logo">NTspark</h1>
        
        <div class="speed-container">
            <div class="instant-feedback" id="feedback"></div>
            <div class="accuracy-indicator" id="accuracy">High Precision Mode</div>
            <div class="speed-display" id="speedDisplay">
                <span id="speedValue">--</span>
                <span class="speed-unit">Mbps</span>
            </div>
            
            <svg class="progress-ring" id="progressRing">
                <defs>
                    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#00f5ff"/>
                        <stop offset="100%" style="stop-color:#ff006e"/>
                    </linearGradient>
                </defs>
                <circle class="bg" cx="100" cy="100" r="100"/>
                <circle class="progress" cx="100" cy="100" r="100" id="progressCircle"/>
            </svg>
        </div>

        <div class="status" id="status">Ready to test your internet speed</div>
        
        <div class="connection-dots" id="connectionDots">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
        </div>

        <button class="start-btn" id="startBtn" onclick="startTest()">
            <span id="btnText">GO</span>
        </button>

        <div class="stats" id="stats">
            <div class="stat">
                <div class="stat-value" id="downloadStat">--</div>
                <div class="stat-label">Download</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="uploadStat">--</div>
                <div class="stat-label">Upload</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="pingStat">--</div>
                <div class="stat-label">Ping</div>
            </div>
        </div>

        <div class="network-info" id="networkInfo">
            <div>Detecting location...</div>
        </div>
    </div>

    <script>
        class AccurateSpeedTest {
            constructor() {
                this.isRunning = false;
                this.testData = {
                    download: 0,
                    upload: 0,
                    ping: 0,
                    jitter: 0
                };
                
                // Multiple test endpoints for better accuracy
                this.testEndpoints = [
                    { url: 'https://www.gstatic.com/generate_204', type: 'ping' },
                    { url: 'https://httpbin.org/bytes/', type: 'download' },
                    { url: 'https://httpbin.org/post', type: 'upload' },
                    { url: 'https://cloudflare.com/cdn-cgi/trace', type: 'latency' }
                ];
                
                // Connection preheating
                this.connectionEstablished = false;
                this.calibrationComplete = false;
                
                this.init();
            }

            async init() {
                await this.detectNetworkCapabilities();
                await this.calibrateConnection();
                this.preEstablishConnections();
            }

            async detectNetworkCapabilities() {
                try {
                    // Detect connection type using Navigator API
                    if ('connection' in navigator) {
                        const conn = navigator.connection;
                        const effectiveType = conn.effectiveType || 'unknown';
                        const downlink = conn.downlink || 0;
                        
                        document.getElementById('networkInfo').innerHTML = `
                            <div>Connection: ${effectiveType.toUpperCase()} • Est. ${downlink}Mbps</div>
                        `;
                    }
                    
                    // Quick ping to primary servers
                    const pingResults = await this.multiServerPing();
                    const avgPing = pingResults.reduce((a, b) => a + b, 0) / pingResults.length;
                    
                    this.showFeedback(`Network ready • ${Math.round(avgPing)}ms latency`);
                    
                } catch (error) {
                    console.warn('Network detection failed:', error);
                }
            }

            async multiServerPing() {
                const pingPromises = [
                    this.precisePing('https://www.google.com/generate_204'),
                    this.precisePing('https://www.cloudflare.com/'),
                    this.precisePing('https://httpbin.org/get')
                ];

                const results = await Promise.allSettled(pingPromises);
                return results
                    .filter(r => r.status === 'fulfilled' && r.value > 0 && r.value < 2000)
                    .map(r => r.value);
            }

            async precisePing(url) {
                const measurements = [];
                
                for (let i = 0; i < 3; i++) {
                    try {
                        const start = performance.now();
                        const response = await fetch(url, {
                            method: 'HEAD',
                            cache: 'no-cache',
                            mode: 'no-cors',
                            signal: AbortSignal.timeout(3000)
                        });
                        const end = performance.now();
                        measurements.push(end - start);
                    } catch (error) {
                        // Fallback measurement using image loading
                        try {
                            const start = performance.now();
                            await new Promise((resolve, reject) => {
                                const img = new Image();
                                img.onload = () => resolve();
                                img.onerror = () => reject();
                                img.src = url + '?t=' + Date.now();
                                setTimeout(() => reject(), 2000);
                            });
                            const end = performance.now();
                            measurements.push(end - start);
                        } catch (imgError) {
                            measurements.push(0);
                        }
                    }
                    
                    if (i < 2) await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const validMeasurements = measurements.filter(m => m > 0);
                return validMeasurements.length > 0 
                    ? validMeasurements.reduce((a, b) => a + b) / validMeasurements.length 
                    : 0;
            }

            async calibrateConnection() {
                try {
                    // Warm up connections with progressive loading
                    const warmupSizes = [1024, 5120, 10240]; // 1KB, 5KB, 10KB
                    
                    for (const size of warmupSizes) {
                        await this.downloadTestData(size, 1000); // 1 second timeout
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    this.calibrationComplete = true;
                } catch (error) {
                    console.warn('Calibration incomplete:', error);
                }
            }

            async preEstablishConnections() {
                const connectionPromises = this.testEndpoints.map(endpoint => 
                    fetch(endpoint.url, { 
                        method: 'HEAD', 
                        cache: 'no-cache',
                        signal: AbortSignal.timeout(2000)
                    }).catch(() => {})
                );
                
                await Promise.allSettled(connectionPromises);
                this.connectionEstablished = true;
            }

            async downloadTestData(sizeBytes, timeoutMs = 10000) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
                
                try {
                    const response = await fetch(`https://httpbin.org/bytes/${sizeBytes}`, {
                        signal: controller.signal,
                        cache: 'no-cache'
                    });
                    
                    const data = await response.arrayBuffer();
                    clearTimeout(timeoutId);
                    
                    return {
                        bytes: data.byteLength,
                        success: true
                    };
                } catch (error) {
                    clearTimeout(timeoutId);
                    return { bytes: 0, success: false };
                }
            }

            async accurateDownloadTest() {
                const testDuration = 8000; // 8 seconds for accuracy
                const startTime = performance.now();
                let totalBytes = 0;
                let measurements = [];
                let currentSpeed = 0;

                // Progressive size testing for accuracy
                const testSizes = [
                    { size: 50 * 1024, duration: 2000 },   // 50KB - 2s
                    { size: 200 * 1024, duration: 3000 },  // 200KB - 3s  
                    { size: 500 * 1024, duration: 3000 }   // 500KB - 3s
                ];

                for (let phase = 0; phase < testSizes.length && this.isRunning; phase++) {
                    const { size, duration } = testSizes[phase];
                    const phaseStart = performance.now();
                    
                    while (performance.now() - phaseStart < duration && this.isRunning) {
                        const downloadStart = performance.now();
                        const result = await this.downloadTestData(size, 5000);
                        const downloadTime = performance.now() - downloadStart;
                        
                        if (result.success && result.bytes > 0 && downloadTime > 0) {
                            totalBytes += result.bytes;
                            const instantSpeed = (result.bytes * 8) / (downloadTime / 1000) / (1024 * 1024);
                            measurements.push(instantSpeed);
                            
                            // Real-time speed calculation with smoothing
                            const recentMeasurements = measurements.slice(-5);
                            currentSpeed = recentMeasurements.reduce((a, b) => a + b) / recentMeasurements.length;
                            
                            this.updateDisplay(currentSpeed.toFixed(1), 'Mbps', true);
                            
                            // Progress update
                            const overallProgress = ((performance.now() - startTime) / testDuration) * 70;
                            this.updateProgress(Math.min(overallProgress, 70));
                        }
                        
                        // Small delay to prevent overwhelming the server
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }

                // Calculate final speed using median of measurements for accuracy
                if (measurements.length > 0) {
                    measurements.sort((a, b) => a - b);
                    const medianIndex = Math.floor(measurements.length / 2);
                    return measurements.length % 2 === 0 
                        ? (measurements[medianIndex - 1] + measurements[medianIndex]) / 2
                        : measurements[medianIndex];
                }

                return currentSpeed;
            }

            async accurateUploadTest() {
                const measurements = [];
                const testSizes = [25 * 1024, 50 * 1024, 100 * 1024]; // 25KB, 50KB, 100KB
                
                for (const size of testSizes) {
                    if (!this.isRunning) break;
                    
                    const testData = new Uint8Array(size);
                    // Fill with random data for realistic testing
                    for (let i = 0; i < testData.length; i++) {
                        testData[i] = Math.floor(Math.random() * 256);
                    }
                    
                    const startTime = performance.now();
                    
                    try {
                        const response = await fetch('https://httpbin.org/post', {
                            method: 'POST',
                            body: testData,
                            headers: {
                                'Content-Type': 'application/octet-stream'
                            },
                            signal: AbortSignal.timeout(5000)
                        });
                        
                        const duration = (performance.now() - startTime) / 1000;
                        const uploadSpeed = (testData.byteLength * 8) / (duration * 1024 * 1024);
                        
                        if (uploadSpeed > 0 && uploadSpeed < 1000) { // Sanity check
                            measurements.push(uploadSpeed);
                        }
                        
                        this.updateProgress(75 + (measurements.length / testSizes.length) * 15);
                        
                    } catch (error) {
                        console.warn('Upload test failed:', error);
                    }
                }

                // Return median upload speed
                if (measurements.length > 0) {
                    measurements.sort((a, b) => a - b);
                    const medianIndex = Math.floor(measurements.length / 2);
                    return measurements.length % 2 === 0 
                        ? (measurements[medianIndex - 1] + measurements[medianIndex]) / 2
                        : measurements[medianIndex];
                }

                return 0;
            }

            async comprehensivePingTest() {
                const pingResults = [];
                const jitterResults = [];
                
                // Multiple ping measurements for accuracy
                for (let i = 0; i < 10; i++) {
                    if (!this.isRunning) break;
                    
                    const pingTime = await this.precisePing('https://httpbin.org/get');
                    if (pingTime > 0 && pingTime < 2000) {
                        pingResults.push(pingTime);
                        
                        if (pingResults.length > 1) {
                            const jitter = Math.abs(pingTime - pingResults[pingResults.length - 2]);
                            jitterResults.push(jitter);
                        }
                    }
                    
                    this.updateDisplay(Math.round(pingTime), 'ms');
                    this.updateProgress(5 + (i / 10) * 5);
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                const avgPing = pingResults.length > 0 
                    ? pingResults.reduce((a, b) => a + b) / pingResults.length 
                    : 0;
                
                const avgJitter = jitterResults.length > 0 
                    ? jitterResults.reduce((a, b) => a + b) / jitterResults.length 
                    : 0;

                this.testData.jitter = avgJitter;
                return avgPing;
            }

            updateProgress(percent) {
                const circle = document.getElementById('progressCircle');
                const circumference = 2 * Math.PI * 100;
                const offset = circumference - (percent / 100) * circumference;
                circle.style.strokeDashoffset = offset;
            }

            updateDisplay(value, suffix = 'Mbps', isActive = false) {
                const speedValue = document.getElementById('speedValue');
                const speedDisplay = document.getElementById('speedDisplay');
                
                speedValue.textContent = value;
                speedDisplay.className = isActive ? 'speed-display testing' : 'speed-display';
            }

            showFeedback(message) {
                const feedback = document.getElementById('feedback');
                feedback.textContent = message;
                feedback.classList.add('show');
                setTimeout(() => feedback.classList.remove('show'), 3000);
            }

            async start() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                
                // Show accuracy indicator
                document.getElementById('accuracy').classList.add('show');
                
                // Update UI
                document.getElementById('startBtn').disabled = true;
                document.getElementById('btnText').textContent = 'Testing...';
                document.getElementById('progressRing').classList.add('active');
                document.getElementById('connectionDots').classList.add('show');
                document.getElementById('status').textContent = 'Initializing accurate test...';

                try {
                    // Phase 1: Comprehensive ping test
                    document.getElementById('status').textContent = 'Measuring latency & jitter...';
                    const ping = await this.comprehensivePingTest();
                    this.testData.ping = ping;
                    
                    if (!this.isRunning) return;
                    
                    // Phase 2: Accurate download test
                    document.getElementById('status').textContent = 'Testing download bandwidth...';
                    this.showFeedback('High precision measurement in progress...');
                    
                    const downloadSpeed = await this.accurateDownloadTest();
                    this.testData.download = downloadSpeed;
                    
                    if (!this.isRunning) return;
                    
                    // Phase 3: Upload test
                    document.getElementById('status').textContent = 'Testing upload bandwidth...';
                    const uploadSpeed = await this.accurateUploadTest();
                    this.testData.upload = uploadSpeed;
                    
                    // Complete test
                    this.completeTest();
                    
                } catch (error) {
                    console.error('Test error:', error);
                    this.showFeedback('Test completed with available data');
                    this.completeTest();
                }
            }

            completeTest() {
                this.isRunning = false;
                this.updateProgress(100);
                
                // Show final download speed
                this.updateDisplay(this.testData.download.toFixed(1), 'Mbps', false);
                document.getElementById('status').textContent = 'High-precision test completed!';
                
                // Update stats with more precision
                document.getElementById('downloadStat').textContent = this.testData.download.toFixed(2) + ' Mbps';
                document.getElementById('uploadStat').textContent = this.testData.upload.toFixed(2) + ' Mbps';
                document.getElementById('pingStat').textContent = Math.round(this.testData.ping) + ' ms';
                
                // Show results
                document.getElementById('stats').classList.add('show');
                
                // Reset UI
                setTimeout(() => {
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('btnText').textContent = 'Test Again';
                    document.getElementById('progressRing').classList.remove('active');
                    document.getElementById('connectionDots').classList.remove('show');
                    document.getElementById('accuracy').classList.remove('show');
                }, 1500);
                
                this.showFeedback(`Accurate result: ${this.testData.download.toFixed(2)} Mbps`);
            }

            stop() {
                this.isRunning = false;
                this.completeTest();
            }
        }

        // Initialize
        const speedTest = new AccurateSpeedTest();

        function startTest() {
            if (speedTest.isRunning) {
                speedTest.stop();
            } else {
                // Reset stats
                document.getElementById('stats').classList.remove('show');
                speedTest.start();
            }
        }

        // Show readiness after initialization
        setTimeout(() => {
            if (!speedTest.isRunning) {
                document.getElementById('status').textContent = 'Ready for accurate speed measurement';
                speedTest.showFeedback('Calibrated and ready for testing');
            }
        }, 3000);
    </script>
</body>
</html>